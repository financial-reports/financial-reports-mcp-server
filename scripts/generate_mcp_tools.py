import httpx
import yaml
import jinja2
import re
from pathlib import Path
import json
import asyncio

SCHEMA_URL = "https://financialreports.eu/api/schema/"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "financial_reports_mcp.py"

# --- TEMPLATE START ---

# This header now uses httpx directly and removes the broken SDK
FILE_HEADER_TEMPLATE = """\"\"\"
AUTO-GENERATED FILE by scripts/generate_mcp_tools.py
Do not edit this file directly. Instead, edit the script and/or the Jinja2 template.
\"\"\"
import os
from typing import Any, Coroutine
from mcp.server.fastmcp import FastMCP
import httpx
import json
import asyncio

mcp = FastMCP("financial-reports")

API_KEY = os.environ.get("API_KEY")
API_BASE_URL = os.environ.get("API_BASE_URL", "https://api.financialreports.eu")

if not API_KEY:
    raise ValueError("API_KEY environment variable not set.")

# --- THIS IS THE FIX ---
# We create a single, reusable httpx client, just like in the test script.
# This client will correctly send the API key and disable SSL checks.
headers = {
    'X-API-Key': API_KEY,
    'User-Agent': 'FinancialReports-MCP-Server/1.0'
}
client = httpx.AsyncClient(
    base_url=API_BASE_URL,
    headers=headers,
    verify=False, # Disables SSL certificate check
    timeout=30.0
)
# --- END FIX ---
"""

# This function is now *outside* the header template
FUNCTION_DEFINITIONS = """
async def format_response(response: httpx.Response) -> str:
    \"\"\"Formats an httpx.Response into a JSON string for the LLM.\"\"\"
    try:
        response.raise_for_status() # Raise an exception for 4xx or 5xx errors
        data = response.json()
        
        json_string = json.dumps(data, indent=2)
        return f\"\"\"```json
{json_string}
```\"\"\"
    except httpx.HTTPStatusError as e:
        return f"Error: {e.response.status_code} {e.response.reason_phrase}\\nBody: {e.response.text}"
    except Exception as e:
        return f"Error formatting response: {e}"

# --- Auto-Generated Tools ---
"""

# This template now generates raw httpx calls
TOOL_TEMPLATE = """
@mcp.tool()
async def {{ func_name }}(
    {%- for param in params %}
    {{ param.name }}: {{ param.py_type }}{{ param.default_val }},
    {%- endfor %}
) -> str:
    \"\"\"
    {{ description }}

    Args:
    {%- for param in params %}
        {{ param.name }} ({{ param.py_type_str }}): {{ param.description }}
    {%- endfor %}
    \"\"\"
    try:
        # Separate query params from path params
        query_params = {
            {%- for param in params if param.is_query %}
            "{{ param.name }}": {{ param.name }},
            {%- endfor %}
        }
        
        path_params = {
            {%- for param in params if param.is_path %}
            "{{ param.name }}": {{ param.name }},
            {%- endfor %}
        }
        
        # Format the URL with path parameters
        url = f"{{ path }}"
        if path_params:
            url = url.format(**path_params)

        # Make the raw httpx request
        response = await client.get(
            url,
            params={k: v for k, v in query_params.items() if v is not None}
        )
        
        return await format_response(response)
    except Exception as e:
        return f"Error calling API: {e}"
"""
# --- TEMPLATE END ---

def get_python_type(schema_type, schema_format=None, is_required=True, default=None):
    py_type = "Any"
    if schema_type == "integer": py_type = "int"
    elif schema_type == "number": py_type = "float"
    elif schema_type == "string": py_type = "str"
    elif schema_type == "boolean": py_type = "bool"
    elif schema_type == "array": py_type = "list"
    elif schema_type == "object": py_type = "dict"

    py_type_str = py_type
    default_val = ""

    if not is_required:
        py_type = f"{py_type} | None"
        py_type_str = f"Optional[{py_type_str}]"
        default_val = " = None"
    
    if default is not None:
        if schema_type == "string":
            default_val = f' = "{default}"'
        else:
            default_val = f" = {default}"
         
    if is_required and default is None:
         default_val = ""

    return py_type, py_type_str, default_val

def snake_case(s):
    s = re.sub(r'(?<!^)(?=[A-Z])', '_', s).lower()
    return re.sub(r'[^a-z0-9_]+', '_', s).strip('_')

def main():
    try:
        response = httpx.get(SCHEMA_URL)
        response.raise_for_status()
        schema = yaml.safe_load(response.content)
    except Exception as e:
        print(f"Failed to download or parse schema: {e}")
        return

    env = jinja2.Environment()
    tool_template = env.from_string(TOOL_TEMPLATE)

    # We now build the file in parts
    generated_code = [FILE_HEADER_TEMPLATE, FUNCTION_DEFINITIONS]

    paths = schema.get("paths", {})
    for path, path_item in paths.items():
        if "get" not in path_item:
            continue
        
        operation = path_item["get"]
        operation_id = operation.get("operationId")
        if not operation_id:
            continue

        func_name = snake_case(operation_id)
        description = operation.get("description", "No description available.").strip()
        
        params = []
        schema_params = operation.get("parameters", [])
        
        for param in schema_params:
            name = param["name"]
            is_path = param["in"] == "path"
            is_query = param["in"] == "query"
            is_required = param.get("required", False)
            param_schema = param.get("schema", {})
            schema_type = param_schema.get("type")
            schema_format = param_schema.get("format")
            default = param_schema.get("default")
            
            py_type, py_type_str, default_val = get_python_type(schema_type, schema_format, is_required, default)
            
            params.append({
                "name": snake_case(name),
                "py_type": py_type,
                "py_type_str": py_type_str,
                "default_val": default_val,
                "description": param.get("description", "").strip(),
                "is_path": is_path,
                "is_query": is_query,
            })

        # Convert /api/companies/{id}/ to /api/companies/{id}/ for f-string formatting
        # We must also escape the braces for the f-string
        formatted_path = re.sub(r'\{([^}]+)\}', r'{\1}', path)
        
        tool_context = {
            "func_name": func_name,
            "description": description,
            "params": params,
            "path": formatted_path
        }
        
        generated_code.append(tool_template.render(tool_context))

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(generated_code))
        f.write("\n\n# --- Main entrypoint ---\n")
        f.write("def main():\n")
        f.write("    try:\n")
        f.write("        mcp.run(transport='stdio')\n")
        f.write("    finally:\n")
        f.write("        try:\n")
        f.write("            asyncio.run(client.aclose())\n")
        f.write("        except Exception as e:\n")
        f.write("            print(f\"Error closing httpx client: {e}\")\n\n")
        f.write("if __name__ == \"__main__\":\n")
        f.write("    main()\n")

    print(f"Successfully generated MCP server tools at: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()